"""using the reasearch paper on  Phonon transport at interfaces: [Determining the correct modes of vibration](https://bpb-us-e1.wpmucdn.com/sites.mit.edu/dist/6/1786/files/2019/10/2015-Phonon-Transport-at-Interfaces-Determining-the-Correct-Modes-of-Vibration.pdf) published by Kiarash Gordiz, and Asegun Henry"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_phonon_intro.ipynb.

# %% auto 0
__all__ = ['mL', 'kL', 'mR', 'kR', 'N', 'm', 'K_dev', 'Minv_sqrt', 'D_dev', 'H0L', 'H1L', 'H0R', 'H1R', 'VL', 'VR', 'ws', 'Ts',
           'w2_vals', 'U', 'w_vals', 'end_coupling_weight', 'device_force_constants', 'lead_blocks', 'sancho_rubio',
           'surface_g_mono', 'gamma_from_sigma', 'transmission_at', 'spectral_channels']

# %% ../nbs/02_phonon_intro.ipynb 7
import numpy as np 
from numpy.linalg import inv, eig
from scipy.linalg import eigh

# %% ../nbs/02_phonon_intro.ipynb 9
# Left material
mL, kL = 1.0, 1.0
# Right material
mR, kR = 2.0, 0.6
N = 8
m = np.array([mL]*(N//2) + [mR]*(N - N //2))

# %% ../nbs/02_phonon_intro.ipynb 11
def device_force_constants(N: int, k_left: float, k_right: float) -> np.ndarray:
    """
    Build the NxN force-constant (Hessian) matrix K for a 1D chain with an interface.
    - First half bonds use k_left
    - Second half bonds use k_right
    Nearest-neighbor springs only (tridiagonal K).
    """
    K = np.zeros((N, N), dtype=float)

    for i in range(N):
        # left bond (i-1 <-> i)
        if i > 0:
            kij = k_left if (i - 1) < (N // 2) else k_right
            K[i, i]   += kij
            K[i, i-1] -= kij

        # right bond (i <-> i+1)
        if i < N - 1:
            kij = k_left if i < (N // 2) else k_right
            K[i, i]   += kij
            K[i, i+1] -= kij

    return K


# %% ../nbs/02_phonon_intro.ipynb 12
K_dev = device_force_constants(N, kL, kR)

#Mass-normalize: D = $M^{-1/2} K M^{-1/2}$
Minv_sqrt = np.diag(1.0 / np.sqrt(m))
D_dev = Minv_sqrt @ K_dev @ Minv_sqrt
D_dev

# %% ../nbs/02_phonon_intro.ipynb 14
from numpy.linalg import inv

def lead_blocks(mass: float, kspring: float):
    h0 = 2.0 * kspring / mass
    h1 = -1.0 * kspring / mass
    H0 = np.array([[h0]], dtype=float)
    H1 = np.array([[h1]], dtype=float)
    return H0, H1

def sancho_rubio(H0: np.ndarray, H1: np.ndarray, w2: float, eta: float = 1e-12, max_iter: int = 200):
    """Surface Green's function g^r for a semi-infinite 1D chain (1x1 blocks)."""
    z = w2 + 1j*eta
    a = H0.copy()
    b = H1.copy()
    for _ in range(max_iter):
        g = inv(z*np.eye(a.shape[0]) - a)
        a_new = a + b @ g @ b.T
        b_new = b @ g @ b
        if np.allclose(a_new, a) and np.allclose(b_new, b):
            a, b = a_new, b_new
            break
        a, b = a_new, b_new
    gsurf = inv(z*np.eye(a.shape[0]) - a)
    return gsurf

# Build left/right lead blocks
H0L, H1L = lead_blocks(mL, kL)
H0R, H1R = lead_blocks(mR, kR)

def surface_g_mono(w: float, m: float, k: float, eta: float = 1e-6) -> np.ndarray:
    """
    Retarded surface Green's function g^r(ω) for a semi-infinite 1D monatomic chain
    in the *mass-normalized* basis.

    Chain blocks: H0 = 2k/m, H1 = -k/m (scalar).
    g satisfies: (h1^2) g^2 - (z - h0) g + 1 = 0,  z=ω^2+iη.
    Pick the root with Im(g) < 0 (retarded condition).
    """
    z  = w**2 + 1j*eta
    h0 = 2.0 * k / m
    h1 = -1.0 * k / m
    a  = z - h0
    b2 = h1 * h1

    # complex-safe sqrt
    root = np.lib.scimath.sqrt(a*a - 4.0*b2)
    g1 = (a - root) / (2.0*b2)
    g2 = (a + root) / (2.0*b2)

    g = g1 if np.imag(g1) < 0 else g2  # retarded: Im(g) < 0
    return np.array([[g]], dtype=complex)


# %% ../nbs/02_phonon_intro.ipynb 16
def gamma_from_sigma(Sigma: np.ndarray) -> np.ndarray:
    return 1j * (Sigma - Sigma.conj().T)

# Coupling vectors in mass-normalized basis
VL = np.zeros((N, 1)); VL[0, 0]  = -np.sqrt(kL / mL)
VR = np.zeros((N, 1)); VR[-1, 0] = -np.sqrt(kR / mR)

def transmission_at(w: float, eta: float = 1e-6):
    # 1x1 surface GFs via closed-form
    gL = surface_g_mono(w, mL, kL, eta=eta)
    gR = surface_g_mono(w, mR, kR, eta=eta)

    SigmaL = VL @ gL @ VL.T
    SigmaR = VR @ gR @ VR.T

    GammaL = 1j * (SigmaL - SigmaL.conj().T)
    GammaR = 1j * (SigmaR - SigmaR.conj().T)

    z = (w**2 + 1j*eta)
    G = np.linalg.inv(z*np.eye(N) - D_dev - SigmaL - SigmaR)

    T = np.real(np.trace(GammaL @ G @ GammaR @ G.conj().T))
    return float(T), G, SigmaL, SigmaR



# %% ../nbs/02_phonon_intro.ipynb 18
import numpy as np
import matplotlib.pyplot as plt

ws = np.linspace(0.0, 2.2, 200)
Ts = [transmission_at(w)[0] for w in ws]

plt.figure()
plt.plot(ws, Ts)
plt.xlabel(r'$\omega$')
plt.ylabel(r'$T(\omega)$')
plt.title('Phonon transmission across the interface')
plt.show()


# %% ../nbs/02_phonon_intro.ipynb 20
from scipy.linalg import eigh

w2_vals, U = eigh(D_dev)                     # D U = U diag(w^2)
w_vals = np.sqrt(np.clip(w2_vals, 0, None))  # frequencies

# Heuristic coupling measure: weight on the two boundary atoms
end_coupling_weight = (U[0, :]**2 + U[-1, :]**2)

# Peek at the first few modes (frequency and end-coupling weight)
list(zip(w_vals[:5].round(4), end_coupling_weight[:5].round(4)))


# %% ../nbs/02_phonon_intro.ipynb 22
def spectral_channels(G: np.ndarray):
    A = 1j * (G - G.conj().T)
    # Hermitian stabilization for numerical safety
    A_herm = 0.5 * (A + A.conj().T)
    evals, evecs = eigh(A_herm)
    return evals, evecs, A

