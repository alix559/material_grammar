[
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "foo\n\n foo ()"
  },
  {
    "objectID": "study_plan.html",
    "href": "study_plan.html",
    "title": "Study Plan",
    "section": "",
    "text": "Newton‚Äôs law for lattice vibrations: \\[ M\\,\\ddot{u}(t) = -K\\,u(t) \\]\nHarmonic ansatz: \\[ u(t) = U\\,e^{-i\\omega t} \\]\nGeneralized eigenproblem (natural frequencies/modes): \\[ (K - \\omega^2 M)\\,U = 0 \\]\nMass-normalized form: \\[ D = M^{-1/2} K M^{-1/2}, \\qquad D\\,U = \\omega^2 U, \\qquad U^\\top U = I \\]\n\nRelevance to the paper: This is the starting point; the paper‚Äôs central claim is that the correct modes for interfacial transport are the eigenmodes of the entire interface system (from the above eigenproblem), not the bulk modes of the isolated materials.\n\n\n\n\n\nMonatomic 1D chain with mass \\(m\\) and spring \\(k\\): \\[ \\omega(q) = 2\\sqrt{\\frac{k}{m}}\\,\\Big|\\sin\\!\\frac{qa}{2}\\Big| \\]\n\nRelevance to the paper: Knowing lead band limits clarifies where propagating vs evanescent modes live, which affects which interface modes can actually carry energy across the junction.\n\n\n\n\nLet \\(z=\\omega^2+i\\eta\\), \\(h_0=\\tfrac{2k}{m}\\), \\(h_1=-\\tfrac{k}{m}\\). The surface Green‚Äôs function \\(g\\) solves \\[ h_1^2\\,g^2 - (z - h_0)\\,g + 1 = 0, \\qquad \\text{choose the root with } \\Im g &lt; 0. \\]\nRelevance to the paper: Interfaces are treated by embedding semi-infinite leads; the self-energies below use these \\(g\\)‚Äôs, which then feed the device Green‚Äôs function used for mode-resolved transmission.\n\n\n\n\n\nSelf-energies: \\[ \\Sigma_{L}(\\omega) = V_L\\, g_L(\\omega)\\, V_L^\\top, \\qquad \\Sigma_{R}(\\omega) = V_R\\, g_R(\\omega)\\, V_R^\\top \\]\nBroadening (coupling) matrices: \\[ \\Gamma_{L} = i\\!\\left(\\Sigma_L - \\Sigma_L^\\dagger\\right), \\qquad \\Gamma_{R} = i\\!\\left(\\Sigma_R - \\Sigma_R^\\dagger\\right) \\]\n\nRelevance to the paper: These capture how the bulk leads couple into the interface region; the paper‚Äôs mode-correction is about what basis you use when interpreting the transmission that results.\n\n\n\n\n\\[ G(\\omega) = \\Big[(\\omega^2 + i\\eta)I - D - \\Sigma_L(\\omega) - \\Sigma_R(\\omega)\\Big]^{-1} \\]\nRelevance to the paper: \\(G(\\omega)\\) is the engine of transport; the paper emphasizes that mode analysis should be done in the eigenbasis of the full interface system associated with \\(D\\), not projected onto bulk eigenmodes.\n\n\n\n\n\\[ T(\\omega) = \\mathrm{Tr}\\!\\Big[\\Gamma_L\\, G\\, \\Gamma_R\\, G^\\dagger\\Big] \\]\nRelevance to the paper: This is the scalar quantity everyone reports. The paper clarifies how to decompose \\(T(\\omega)\\) correctly into contributions of the interface‚Äôs own modes, avoiding misinterpretation from bulk-mode projections.\n\n\n\n\n\nSpectral function: \\[ A(\\omega) = i\\!\\left(G - G^\\dagger\\right) \\]\nLocal/total phonon DOS: \\[ \\rho(\\omega) = \\frac{1}{2\\pi}\\,\\mathrm{Tr}\\!\\big[A(\\omega)\\big] \\]\n\nRelevance to the paper: Diagonalizing \\(A(\\omega)\\) (or projecting responses onto system modes \\(U\\)) lets you build mode-resolved channels consistent with the ‚Äúcorrect modes‚Äù definition at the interface.\n\n\n\n\n\nHeat current: \\[ J = \\int_0^\\infty \\frac{\\hbar \\omega}{2\\pi}\\, T(\\omega)\\,\\Big[n_B(\\omega,T_L) - n_B(\\omega,T_R)\\Big]\\, d\\omega \\] where \\(n_B(\\omega,T)=\\frac{1}{e^{\\hbar\\omega/k_BT}-1}\\).\nLinear-response thermal conductance: \\[ \\kappa(T) = \\int_0^\\infty \\frac{(\\hbar\\omega)^2}{2\\pi k_B T^2}\\, T(\\omega)\\, n_B(\\omega,T)\\!\\left(1+n_B(\\omega,T)\\right)\\, d\\omega \\]\n\nRelevance to the paper: While the paper is about mode definitions, these relations show how improved, correctly mode-resolved \\(T(\\omega)\\) directly impacts macroscopic thermal predictions.\n\n\n\n\n\nA handy contact-participation metric for system mode \\(n\\): \\[ p_n = \\sum_{i \\in \\text{ends}} |U_{in}|^2 \\]\n\nRelevance to the paper: A practical way to see which interface eigenmodes actually couple to the leads‚Äîaligns with the paper‚Äôs message to interpret transport in terms of interface/system modes rather than bulk ones.",
    "crumbs": [
      "Study Plan"
    ]
  },
  {
    "objectID": "study_plan.html#key-equations-to-learn-for-phonon-transport-at-interfaces",
    "href": "study_plan.html#key-equations-to-learn-for-phonon-transport-at-interfaces",
    "title": "Study Plan",
    "section": "",
    "text": "Newton‚Äôs law for lattice vibrations: \\[ M\\,\\ddot{u}(t) = -K\\,u(t) \\]\nHarmonic ansatz: \\[ u(t) = U\\,e^{-i\\omega t} \\]\nGeneralized eigenproblem (natural frequencies/modes): \\[ (K - \\omega^2 M)\\,U = 0 \\]\nMass-normalized form: \\[ D = M^{-1/2} K M^{-1/2}, \\qquad D\\,U = \\omega^2 U, \\qquad U^\\top U = I \\]\n\nRelevance to the paper: This is the starting point; the paper‚Äôs central claim is that the correct modes for interfacial transport are the eigenmodes of the entire interface system (from the above eigenproblem), not the bulk modes of the isolated materials.\n\n\n\n\n\nMonatomic 1D chain with mass \\(m\\) and spring \\(k\\): \\[ \\omega(q) = 2\\sqrt{\\frac{k}{m}}\\,\\Big|\\sin\\!\\frac{qa}{2}\\Big| \\]\n\nRelevance to the paper: Knowing lead band limits clarifies where propagating vs evanescent modes live, which affects which interface modes can actually carry energy across the junction.\n\n\n\n\nLet \\(z=\\omega^2+i\\eta\\), \\(h_0=\\tfrac{2k}{m}\\), \\(h_1=-\\tfrac{k}{m}\\). The surface Green‚Äôs function \\(g\\) solves \\[ h_1^2\\,g^2 - (z - h_0)\\,g + 1 = 0, \\qquad \\text{choose the root with } \\Im g &lt; 0. \\]\nRelevance to the paper: Interfaces are treated by embedding semi-infinite leads; the self-energies below use these \\(g\\)‚Äôs, which then feed the device Green‚Äôs function used for mode-resolved transmission.\n\n\n\n\n\nSelf-energies: \\[ \\Sigma_{L}(\\omega) = V_L\\, g_L(\\omega)\\, V_L^\\top, \\qquad \\Sigma_{R}(\\omega) = V_R\\, g_R(\\omega)\\, V_R^\\top \\]\nBroadening (coupling) matrices: \\[ \\Gamma_{L} = i\\!\\left(\\Sigma_L - \\Sigma_L^\\dagger\\right), \\qquad \\Gamma_{R} = i\\!\\left(\\Sigma_R - \\Sigma_R^\\dagger\\right) \\]\n\nRelevance to the paper: These capture how the bulk leads couple into the interface region; the paper‚Äôs mode-correction is about what basis you use when interpreting the transmission that results.\n\n\n\n\n\\[ G(\\omega) = \\Big[(\\omega^2 + i\\eta)I - D - \\Sigma_L(\\omega) - \\Sigma_R(\\omega)\\Big]^{-1} \\]\nRelevance to the paper: \\(G(\\omega)\\) is the engine of transport; the paper emphasizes that mode analysis should be done in the eigenbasis of the full interface system associated with \\(D\\), not projected onto bulk eigenmodes.\n\n\n\n\n\\[ T(\\omega) = \\mathrm{Tr}\\!\\Big[\\Gamma_L\\, G\\, \\Gamma_R\\, G^\\dagger\\Big] \\]\nRelevance to the paper: This is the scalar quantity everyone reports. The paper clarifies how to decompose \\(T(\\omega)\\) correctly into contributions of the interface‚Äôs own modes, avoiding misinterpretation from bulk-mode projections.\n\n\n\n\n\nSpectral function: \\[ A(\\omega) = i\\!\\left(G - G^\\dagger\\right) \\]\nLocal/total phonon DOS: \\[ \\rho(\\omega) = \\frac{1}{2\\pi}\\,\\mathrm{Tr}\\!\\big[A(\\omega)\\big] \\]\n\nRelevance to the paper: Diagonalizing \\(A(\\omega)\\) (or projecting responses onto system modes \\(U\\)) lets you build mode-resolved channels consistent with the ‚Äúcorrect modes‚Äù definition at the interface.\n\n\n\n\n\nHeat current: \\[ J = \\int_0^\\infty \\frac{\\hbar \\omega}{2\\pi}\\, T(\\omega)\\,\\Big[n_B(\\omega,T_L) - n_B(\\omega,T_R)\\Big]\\, d\\omega \\] where \\(n_B(\\omega,T)=\\frac{1}{e^{\\hbar\\omega/k_BT}-1}\\).\nLinear-response thermal conductance: \\[ \\kappa(T) = \\int_0^\\infty \\frac{(\\hbar\\omega)^2}{2\\pi k_B T^2}\\, T(\\omega)\\, n_B(\\omega,T)\\!\\left(1+n_B(\\omega,T)\\right)\\, d\\omega \\]\n\nRelevance to the paper: While the paper is about mode definitions, these relations show how improved, correctly mode-resolved \\(T(\\omega)\\) directly impacts macroscopic thermal predictions.\n\n\n\n\n\nA handy contact-participation metric for system mode \\(n\\): \\[ p_n = \\sum_{i \\in \\text{ends}} |U_{in}|^2 \\]\n\nRelevance to the paper: A practical way to see which interface eigenmodes actually couple to the leads‚Äîaligns with the paper‚Äôs message to interpret transport in terms of interface/system modes rather than bulk ones.",
    "crumbs": [
      "Study Plan"
    ]
  },
  {
    "objectID": "study_plan.html#reading-guide-numerical-linear-algebra-for-our-phonon-negf-notebook",
    "href": "study_plan.html#reading-guide-numerical-linear-algebra-for-our-phonon-negf-notebook",
    "title": "Study Plan",
    "section": "üìö Reading Guide: Numerical Linear Algebra for our Phonon-NEGF notebook",
    "text": "üìö Reading Guide: Numerical Linear Algebra for our Phonon-NEGF notebook\nThis sequence maps each concept we used (eigenmodes, Green‚Äôs functions as linear solves, stability, block ops, sparsity, randomized methods) to fastai‚Äôs Numerical Linear Algebra notebooks ‚Äî with a quick ‚Äúwhy this matters for NEGF‚Äù under each.\n\n\n1) Big-picture & accuracy/conditioning basics\n\n1. why are we here ‚Äî overview of matrix computations, accuracy, vectorization\nSets intuition for why small numerical tweaks (like \\(i\\eta\\)) and stable algorithms matter when solving \\((\\omega^2 I - D - \\Sigma_L - \\Sigma_R)\\).\n\n\n\n\n2) Optional: faster big-matrix approximations\n\n4. Randomized SVD ‚Äî when your \\(D\\) or per-frequency solves get big\nUseful to compress large subspaces (e.g., for model reduction or preconditioners) when sweeping many \\(\\omega\\).\n\n\n\n\n3) Block algebra & factorizations (for lead/device partitioning)\n\n5. LU Factorization ‚Äî Gaussian elimination, pivoting, Block Matrix Multiplication\nBlock reasoning underpins self-energies and Schur complements for embedding leads into the device.\n\n\n\n\n4) Sparse thinking & broadcasting (scale up your NEGF)\n\n6. Compressed Sensing of CT Scans with Robust Regression ‚Äî Sparse matrices, broadcasting\n\\(K\\) and \\(D\\) are banded/sparse; sparse ops + broadcasting make frequency sweeps fast and memory-efficient.\n\n\n\n\n5) Stable linear solves (don‚Äôt ‚Äúinvert the matrix‚Äù)\n\n8. How to Implement Linear Regression ‚Äî Normal eqs vs Cholesky/QR/SVD, matrix inversion is unstable, conditioning & stability\nDirect inverses of the Green‚Äôs-function matrix are numerically brittle; prefer factorizations/solves and watch conditioning.\n\n\n\n\n6) Eigenstuff for modes (power/QR/Arnoldi)\n\n9. PageRank with Eigen Decompositions ‚Äî power method, QR, Arnoldi (intuition for mode finding at scale)\nThe ‚Äúcorrect modes‚Äù are eigenvectors of \\(D\\); scalable eigentools help analyze large interface systems.\n\n\n\n\n7) QR details (for stable decompositions)\n\n10. Implementing QR Factorization ‚Äî Gram‚ÄìSchmidt, Householder, stability examples\nQR/Householder give orthogonal transforms that stabilize solves/eigendecompositions used for \\(G(\\omega)\\) and mode analysis.",
    "crumbs": [
      "Study Plan"
    ]
  },
  {
    "objectID": "phonon_intro.html",
    "href": "phonon_intro.html",
    "title": "Phonon Transport at Interfaces",
    "section": "",
    "text": "1. Introduction\nIn solids, atoms are not perfectly still; they vibrate. These vibrations carry heat, much like data packets travel across a network. At ann interface(boundary between two materials), the way vibrations pass through dertermines how well heat flows.\nOur goal: simulate this ‚Äúvibration transport‚Äù using only linear algebra and Python- no advanced physics background needed.\n\n\n2. Equations of Motion -&gt; Matrix Form\nImagine each atom is a point mass attached to its neighbours by springs. The physics law is just newtons second law: \\(M\\ddot{u}(t) = -K u(t)\\). * M : diagonal matrix of atomic masses * K : stiffness (spring constant) matrix * u(t) : displacement vector (positions)\nthis is just like solving a second-order system of ODEs. Instead of time-stepping, we assume vibrations oscillate like \\(u(t) = U e^{-i \\omega t}\\) and reduce the ODE to an eigenvalue problem \\(\\big( K - \\omega^2 M \\big) U = 0\\)\nThis tells us the frequencies \\(\\omega\\) (the signal frequencies) and shapes \\(U\\) (like signal modes).\n\n\n3. The interface problem\n\nThink of a chain of atoms: left half are ‚ÄúMaterial A‚Äù, right half are ‚ÄúMaterial B‚Äù.\nThey are joined in the middle -&gt; the interface.\nEach material supports certain vibration patterns(‚Äúphonons‚Äù).\nAt the interface, do vibrations transmit or reflect?\n\nThis is what we want to compute.\n\n\n4. Lattice Dynamics + Green‚Äôs Functions\nWe use a standard trick: * Transform the equations into frequency domain. * Replace solving Ordinary differential equations with matrix inversion.\nThe central object is the Green‚Äôs function: \\[\nG(\\omega) = \\Big[ \\, (\\omega^2 + i\\eta) I - D - \\Sigma_L(\\omega) - \\Sigma_R(\\omega) \\, \\Big]^{-1}\n\\]\nWhere:\n\n\\(D = M^{-1/2} K M^{-1/2}\\) is the mass-normalized dynamical matrix\n\n\\(\\Sigma_L, \\Sigma_R\\) are the self-energies of the left/right leads\n\n\\(i\\eta\\) is a small numerical damping term (keeps the matrix invertible)\n\n\n\n\nTransmission Function\nOnce \\(G(\\omega)\\) is known, the phonon transmission is:\n\\[\nT(\\omega) = \\mathrm{Tr} \\Big[ \\, \\Gamma_L \\, G \\, \\Gamma_R \\, G^\\dagger \\, \\Big]\n\\]\nwhere\n\\[\n\\Gamma = i \\, \\big( \\Sigma - \\Sigma^\\dagger \\big)\n\\]\n\n\n5. Implementing in Python\nFirst, lets set up a toy 1D model with two materials. Each atom is a mass, each bond a spring.\nBuild the device region: 8 atoms in a chain. Left half: light atoms with strong springs. Right half: heavy atoms with weak springs.\n\n\n5a) Mass matrix and mass-normalized dynamical matrix (D)\nWe convert the force-constant matrix (K) into the mass-normalized dynamical matrix\n\\[\nD \\;=\\; M^{-1/2}\\, K\\, M^{-1/2},\n\\]\nwhere \\(M=\\mathrm{diag}(m_1,\\dots,m_N)\\) comes from the per-atom masses.\nThis converts \\((K-\\omega^2 M)U=0\\) into a standard eigenproblem \\(D U=\\omega^2 U\\).\n\n\n\ndevice_force_constants\n\n device_force_constants (N:int, k_left:float, k_right:float)\n\nBuild the NxN force-constant (Hessian) matrix K for a 1D chain with an interface. - First half bonds use k_left - Second half bonds use k_right Nearest-neighbor springs only (tridiagonal K).\n\n\n6) Leads and surface Green‚Äôs functions (Sancho‚ÄìRubio)\nWe treat the left/right semi-infinite materials (‚Äúleads‚Äù) via their **surface Green‚Äôs functions\\[ g_L, g_R\\] For a 1D monatomic chain (1 DOF per cell), the mass-normalized on-site and coupling blocks are\n\\[\nH_0 = \\frac{2k}{m}, \\qquad H_1 = -\\frac{k}{m}.\n\\]\nWe compute the surface Green‚Äôs function using the Sancho‚ÄìRubio decimation (a fixed-point block-matrix iteration).\n\n\n\nsurface_g_mono\n\n surface_g_mono (w:float, m:float, k:float, eta:float=1e-06)\n\nRetarded surface Green‚Äôs function g^r(œâ) for a semi-infinite 1D monatomic chain in the mass-normalized* basis.\nChain blocks: H0 = 2k/m, H1 = -k/m (scalar). g satisfies: (h1^2) g^2 - (z - h0) g + 1 = 0, z=œâ^2+iŒ∑. Pick the root with Im(g) &lt; 0 (retarded condition).*\n\n\n\nsancho_rubio\n\n sancho_rubio (H0:numpy.ndarray, H1:numpy.ndarray, w2:float,\n               eta:float=1e-12, max_iter:int=200)\n\nSurface Green‚Äôs function g^r for a semi-infinite 1D chain (1x1 blocks).\n\n\n\nlead_blocks\n\n lead_blocks (mass:float, kspring:float)\n\n\n\n7) Self-energies, device Green‚Äôs function, and transmission\nCouple the device‚Äôs end atoms to the leads. In the mass-normalized basis, the coupling vectors are\n\\[\nV_L[0]=-\\sqrt{k_L/m_L}, \\quad V_R[-1]=-\\sqrt{k_R/m_R}.\n\\]\nThen compute: - Lead self-energies \\(\\Sigma_{L,R} = V_{L,R}\\, g_{L,R}\\, V_{L,R}^T\\) - Broadening matrices \\(\\Gamma = i(\\Sigma - \\Sigma^\\dagger)\\) - Device Green‚Äôs function \\(G = \\big[(\\omega^2+i\\eta)I - D - \\Sigma_L - \\Sigma_R\\big]^{-1}\\) - Transmission \\(T(\\omega) = \\mathrm{Tr}\\big[\\Gamma_L\\, G\\, \\Gamma_R\\, G^\\dagger\\big]\\)\n\n\n\ntransmission_at\n\n transmission_at (w:float, eta:float=1e-06)\n\n\n\n\ngamma_from_sigma\n\n gamma_from_sigma (Sigma:numpy.ndarray)\n\n\n\n8) Frequency sweep and plot \\(T(\\omega)\\)\nWe scan $ ¬†$ and visualize the transmission spectrum.\n\n\n9) System eigenmodes (the Gordiz‚ÄìHenry ‚Äúcorrect modes‚Äù)\nDiagonalize the device‚Äôs dynamical matrix (D) to obtain eigenpairs \\((\\omega_n^2, U_n)\\).\nThese are the system modes spanning the interface region (not bulk modes).\nThey provide a physically correct basis to interpret which patterns couple to the leads.\nA quick heuristic: modes with larger amplitude on the end atoms couple better to the leads.\n\n\n10) (Optional) Spectral channels via the spectral function\nFor deeper mode analysis, compute the spectral function $ A()=i(G-G^) $ and diagonalize it to get frequency-resolved transport channels.\n\n\n\nspectral_channels\n\n spectral_channels (G:numpy.ndarray)",
    "crumbs": [
      "Phonon Transport at Interfaces"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "material_grammar",
    "section": "",
    "text": "Install latest from the Github repository\n\n$ pip install git+https://github.com/alix559/material_grammar.git",
    "crumbs": [
      "material_grammar"
    ]
  },
  {
    "objectID": "index.html#usage",
    "href": "index.html#usage",
    "title": "material_grammar",
    "section": "",
    "text": "Install latest from the Github repository\n\n$ pip install git+https://github.com/alix559/material_grammar.git",
    "crumbs": [
      "material_grammar"
    ]
  }
]